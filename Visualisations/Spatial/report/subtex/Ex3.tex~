%discussion
\newpage
\section*{A1.4} %(10) Addition (+) and multiplication (×) are associative in the mathematical sense, meaning that x+(y+z) = (x+y)+z and x×(y×z) = (x×y)×z, which is the reason mathematics allows expressions like x + y + z and x × y × z without explicit parentheses. Most programming languages also allow expressions like x+y+x and x*y*x without parentheses, but they usually specify that the meaning of these are equivalent to (x+y)+x and (x*y)*x, respectively, and not to x+(y+x) or x*(y*x). An alternative would be to let the grouping be unspecified (as in mathematics), since the grouping does not matter for associative operators.

\textbf{What are the benefits and hazards of letting the grouping of + and * be unspecified in a program- ming language?}\\
It is assmued that the programming language specifies the groupings, such that the context free grammar becomes umambigous - namely the expressions has a single, well-defined meaning.\\
Supposing the exercise text meant: $x+y+z$ and $x*y*z$ instead of $x+y+x$ and $x*y*x$. Not that it matters.\\

\underline{Benefits:}\\
I do not see any other benefits than the language being more readable and innate for mathematicians or people, who are already used to expression such as $x+y+z$ and $x*y*z$. However, different programming languages does the grouping of the left and right two terms differently, so they would also have to go through the extra work of examining the language specifications.\\
A potential benefit would be to reduce the extra-verbosity of having to use parentheses to specify the groupings.\\

\underline{Hazards}\\
The major hazard for specifying a certain grouping happens, when floating points are included in the expressions. The nature of how floating points are represented (sign, exponent, mantissa bits), makes it difficult to ensure the intended arithmetic evaluation and rounding.\\
Illustrating this problematic in Python:
\begin{lstlisting}[language = Python]
  Input:
  print(((1.123456789 + 2.123456789) + 3) == (1.123456789 + (2.123456789 + 3)))

  Output:
  False
\end{lstlisting}
(The problem would still persist even if $x+y+x$ and $x*y*x$ was the intention)\\

Making the problem of floating point arithmetic more harzardous, the evaluation is of these are compiler and language dependent.

\newpage
\section*{A1.5} %(10) Solve Exercise 5.7 from the notes.
\underline{advantages}\\
Distinguishing between heap pointers from numbers, would simply entail looking at the memory location directly. If the least significant bit of the heap object is either 1 or 0, we would know immediately whether it is a pointer or number respectively.

\underline{disadvantages}\\
We would need to add extra overhead by allocating some static space for the bitmap in memory, which would map to the entire virtual space. Fetching the bit in the bitmap from memory every time for pointer distinguishing is more expensive than just having the least signifcant bit of every word function as this distinction.\\

\section*{A1.6}
Note: If the sweep phase were to be integrated into the allocation procedure, then we would not have a free list to keep track of the freed blocks.\\

The problem at hand can be illustrated as follows:\\
ax, ay and az represent allocated blocks while numbers indicate the free block size. So with this setup we have(poormans solution to illustrate the heap):
\begin{align*}
ax\\
4\\
ay\\
8\\
az
\end{align*}

Firstly the mark phase is run, where every allocated block's mark bit is set to 1.\\
This becomes:
\begin{align*}
ax-1\\
4-0\\
ay-1\\
8-0\\
az-1
\end{align*}
We want to allocate a block of 8 bytes with malloc(8). So we traverse the heap from the beginning to find suitable free blocks. Doing the sweeping phase simultaneously sets the mark bits of reachable blocks to 0. When the allocator has reached the third block we then have the following situation:
\begin{align*}
ax - 0\\
4 - 0\\
ay - 1
\end{align*}
Now we would have no way of distinguishing between free and allocated blocks - since their mark bits are both 0. In order to fix this problem we would then have to do the marking phase again before doing the allocation. This remarking would be necessary everytime we skip a block that does not meet the allocated requirement.

\section*{A1.7}
We want to identify a programming language feature, which uses a queue instead of a stack for memory management. Essentially this becomes: FIFO(queue) vs. LIFO(stack).
In the "Computer Systems" course we were taught the simple cache block eviction policy: Least Recently Used(LRU). In order to implement this functionality in C, we must naturally keep track of storage references with a queue. For this functionality alone, it would be smart to use a queue for memory management. \\
\\
With the above I have only described a functionality(probably not the intent with this exercise). A language that is heavily based on message parsing, would benefit very much from using a queue as dynamic memory management. In the "Computer Systems" course we were taught socket programming. The idea here is that whenever a client has succesfully established a connection to a server, both parties are then able to send unbounded messages to each other. For a language purely based around this two-way communication, it would be ideal to have the messages stored in memory as a queue, as it only makes sense that these messages should be retrieved in the order they were put into the queue. Thus for this language, the memory holding messages would just get freed immediately after reading the message from memory. As a result messages are read in sequential order, and after reading them, we just get rid of them.