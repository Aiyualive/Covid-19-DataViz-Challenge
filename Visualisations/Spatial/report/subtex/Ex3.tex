\newpage
\section*{A2.3}
In this exercise, we have: $\oplus =$ append operator\\
\\
From 8.3.7.5 homomorphic and linear functions are defined as follows:\\

\textbf{Def1: Linear}:
\begin{center}
A function $f$ is linear if $f(x \oplus y) = f(x) \oplus f(y)$
\end{center}
where $\emptyset$ is a neutral element of $\oplus$, which implies $f(\emptyset) = \emptyset$.\\

\textbf{Def2: Homomorphic}:
\begin{center}
A function $f$ is homomorphic if there exists a value $\iota$ and an operation $\odot$, such that $f(\emptyset ) = \iota$  and $f(x \oplus y)$ = $f(x) \odot f(y)$.
\end{center}

\subsection*{a)}
A linear function $f$ with properties of \textbf{Def1} is also homomorphic, since we have $\odot = \oplus$ and $\iota = \emptyset$ such that using \textbf{Def2}, we get:

\begin{center}
$f(\emptyset ) = \emptyset$  and $f(x \oplus y)$ = $f(x) \oplus f(y)$
\end{center}

\subsection*{b)}
In the following we will use the notation: LS and RS for the lefthandside and righthandside of the equality sign respectively.

% -----------------------
\subsection*{length}
This is not linear, based on the following counterexample:\\
$$
  length( [1,2,3] \; \oplus \; [4,5]) = length( [1,2,3]) \; \oplus \; length( [4,5] )
$$
\\
LS: \tab
$
length( [1,2,3] \; \oplus \; [4,5]) = 5
$

RS: \tab
$
length( [1,2,3]) \; \oplus \; length( [4,5] ) = 3 \oplus 2
$
\\

Since $LS \neq RS$, $length$ is not linear. It is however homomorphic with $\iota = 0$ and $\odot = +$.

% ------------------------
\subsection*{primes}
\textbf{Modification: first equation}
This function is linear:
$$
  primes( [2] \; \oplus \; [3,0,1,3]) = primes( [2]) \; \oplus \; primes( [3,0,1,3] )
$$
\\
LS: \tab
$
primes( [2,3,0,1,3]) = [2,3,3]
$

RS: \tab
$
primes( [2]) \; \oplus \; primes( [3,0,1,3] ) = [2] \oplus [3,3] = [2,3,3]
$
\\

However, the above is just an example. Since the filter function is linear\footnote{as described in the notes p. 162} and we can just filter out the primenumbers, we can be sure that $primes$ is linear and is as such homomorphic as well with $\iota = []$ and $\odot = \oplus$.

% ------------------------
\subsection*{maximal}
This is not linear, based on the following counterexample:
$$
  maximal( [1,2,3] \; \oplus \; [4,5,6]) = maximal([1,2,3]) \; \oplus \; maximal([4,5,6])
$$
\\
LS: \tab
$
maximal( [1,2,3] \; \oplus \; [4,5,6]) = [6]
$

RS: \tab
$
maximal([1,2,3]) \; \oplus \; maximal([4,5,6]) = [3] \oplus [6] = [3,6]
$
\\

Since $LS \neq RS$, $maximal$ is not linear. It is however homomorphic with $\iota = []$ and $\odot = findMax $. Where $findMax$ is implemented in Python:
\begin{lstlisting}[language=Python]
def findMax(l, r):
    # Check for whether the lists are empty
    if( (not l) or (not r)):
        l.extend(r)
        return l
    # Check for same items
    elif(l[0] == r[0]):
        l.extend(r)
        return l
    elif(l[0] > r[0]):
        return l
    elif(r[0] > l[0]):
        return r
    else:
        raise Exception("Something went wrong!")
\end{lstlisting}
The function takes two lists as input (not done type checking), if the first element in either list is greater than the other, we just return the entire list in which the element was greater. Since the lists should have the same elements if the length is greater than 1.

% ------------------------
\subsection*{singleton}
\textcolor{red}{\textbf{Modified:}}\\
This is not linear, based on the following counterexample:
$$
  singleton( [1] \; \oplus \; [1]) = singleton( [1]) \; \oplus \; singleton([1])
$$
\\
LS: \tab
$
 singleton( [1,1] ) = []
$

RS: \tab
$
singleton( [1]) \; \oplus \; singleton([1]) = [1] \oplus [1] = [1,1]
$
\\

Since $LS \neq RS$, $singleton$ is not linear. \\
We now assume that the funciton is homomorphic with $\iota = []$ and $\odot = findSingletons $. Where $findSingletons$\footnote{My method involves working with sets, which are unordered. I assume it is okay to not preserve the original order }  is implemented in Python below(inspiration\footnote{\url{https://stackoverflow.com/questions/7961363/removing-duplicates-in-lists}} \footnote{\url{https://stackoverflow.com/questions/9835762/find-and-list-duplicates-in-a-list}})
\begin{lstlisting}[language = Python]
def findSingletons(l,r):
    # Concatenate two lists
    l.extend(r)

    # Find duplicates
    dup = set([x for x in l if l.count(x) > 1])

    # Find singletons
    singletons = list(set(l)-set(dup))

    return singletons
\end{lstlisting}
Now we would have:
$$
singleton( [1] \; \oplus \; [1]) = singleton( [1]) \; \odot \; singleton([1])
$$
\\
LS: \tab
$
singleton( [1,1] ) = []
$

RS: \tab
$
singleton( [1]) \; \odot \; singleton([1]) = [1] \odot [1] = []
$
\\

However, providing a counter example for this homomorphism:
$$
singleton( [1,1] \; \oplus \; [1]) = singleton( [1,1]) \; \odot \; singleton([1])
$$
\\
LS: \tab
$
singleton( [1,1,1] ) = []
$

RS: \tab
$
singleton( [1,1]) \; \odot \; singleton([1]) = [] \odot [1] = [1]
$
\\

$LS \neq RS$. It is now shown that \texttt{singleton} is not homomorphic with $\iota = []$ and $\odot = findSingletons $. The same can be said for any $\iota$ and $\odot$, since the result is dependent on how the decomposition of the original list is done. I.e how $[1,1,1,1] = [1,1] \oplus [1,1] \quad \vee \quad [1,1,1,1] = [1,1,1] \oplus [1] \quad \vee \quad [1,1,1,1] = [1,1,1,1] \oplus []$ \\

Thus \texttt{singleton} is neither linear nor homomorphic.

\newpage
% ------------------------------------------------
\subsection*{different}
This is not linear, based on the following counterexample:
$$
  different( [1,2,3] \; \oplus \; [1,2,3]) = different( [1,2,3]) \; \oplus \; different( [1,2,3] )
$$
\\
LS: \tab
$
 different( [1,2,3] \; \oplus \; [1,2,3]) = [1,2,3]
$

RS: \tab
$
different( [1,2,3]) \; \oplus \; different( [1,2,3] ) = [1,2,3] \oplus [1,2,3] = [1,2,3,1,2,3]
$
\\

Since $LS \neq RS$, $different$ is not linear. It is however homomorphic with $\iota = []$ and $\odot = findDifferent$. Where $findDifferent$ is implemented in Python below. Similarly to $singletons$, I assume it is okay to not preserve the original order.
\begin{lstlisting}[language = Python]
def findDifferent(l,r):
    # Concatenate two lists
    l.extend(r)

    # Find duplicates
    dup = set([x for x in l if l.count(x) > 1])

    # Apply union operator to find the different elements
    different = list(set(l) | set(dup))

    return different
\end{lstlisting}

% ------------------------
\subsection*{reverse}
This is not linear, based on the following counterexample:
$$
  reverse( [1,2] \; \oplus \; [3,4]) = reverse( [1,2]) \; \oplus \; reverse( [3,4] )
$$
\\
LS: \tab
$
reverse( [1,2] \; \oplus \; [3,4]) = [4,3,2,1]
$

RS: \tab
$
reverse( [1,2]) \; \oplus \; reverse( [3,4] ) = [2,1] \oplus [4,3] = [2,1,4,3]
$
\\

Since $LS \neq RS$, $reverse$ is not linear. It is however homomorphic with $\iota = []$ and $\odot = \texttt{append in reverse order}$.