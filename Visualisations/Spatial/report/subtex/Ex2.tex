\newpage
\section*{A2.2}
In the following we will assume that:
\begin{center}
  $s,s_1,s_2, case\; statements$
\end{center}
are statements containing a block of statements of which the well-defined return type will always be the type of the last statement. Within these blocks any combination of different statements can be formed -- including an arbitrary amount of statements described in each subexercise a) to e).\\
So for example if the last statement in $s$ is a \texttt{do-while} then s returns the type of \texttt{do-while}.  \\

\textbf{a)}\\
\texttt{if} (\textit{e}) $s_1$ \texttt{else} $s_2$\\
To ensure that the if-else-statement always returns a well-defined type, the type of $s_1$ and $s_2$ must always be the same. That is, no matter which of the two cases we enter, the \texttt{if-else} would always return a well-defined type.\\
With this implementation, the programmer has to make sure that each branch returns the same type. As such one becomes much more restricted in the way one writes these \texttt{if-else} statements. This is the only sensible way to return a well-defined type, since the \texttt{if-else} statements needs to enter either branch.\\

\textbf{b)}\\
\texttt{if} (\textit{e}) $s$\\
Now with the \texttt{else} removed, we are only ensured evaluation of $e$. As such we are not ensured execution of $s$. If $e$ is True we would naturally execute $s$ and \texttt{if} would return the type of $s$. If False, we would need to make sure that \texttt{if} returns the same type regardless. This would necessitate a default return value for the False-case.\\

Implementing this in C, the programmer would then define a default return type before executing \texttt{if}. So for instance we have \texttt{char c;} before \texttt{if}.\\
Thus we just need to make sure that $s$ overwrites this value as its last statement, when $e$ is True. Otherwise we return the default value of a char(NULL). With this implementation strategy it allows for different well-defined return types and one is not restricted to enforce one particular well-defined type.\\


\textbf{c)}\\
\texttt{do} $s$ \texttt{while} (\textit{e})\\
Here, we are always ensured that $s$ is executed at least once. So whether or not $e$ is True or False we would always return a well-defined type.\\

This however becomes much more problematic with the introduction of \texttt{break} or \texttt{continue}, shown with the example below:
\begin{lstlisting}
  do {
    int b,n;
    int b = 1;

    if (e2) {
      char k = 'c';
      break;
    }

    if (e3) {
      char* l = "string";
      break;
    }

    if (e4) {
      float m = 3.0;
      continue;
    }
    int n = 2;

  } while (e1);
\end{lstlisting}

Now we would have no way of ensuring which type to return, as we would be able to exit the loop with different executions paths of which each have different return types. That is, the last executed statement varies from each execution path. A naive approach to solve this well-defined type problem, would be to analyze every possible execution path and make sure that the last statement before exiting the loop returns the same type. This however is very tedious, time consuming and too restricted.\\

Another solution is inspired by how UNIX handles \texttt{break} or \texttt{continue} \footnote{\url{https://www.tutorialspoint.com/unix/unix-loop-control.htm}}. In Unix it is possible to provide an argument for the these statements indicating which enclosing loop to exit or continue from. Similarly we can provide an argument for \texttt{break} and \texttt{continue} which is then going to be the return type for the \texttt{do} $s$ \texttt{while} (\textit{e}).
So if we wanted the return type to be int we would then have the following:
\begin{lstlisting}
  do {
    int intLastExec, b, n;

    int b = 1;

    if (e2) {
      char k = 'c';
      break (intLastExec);
    }

    if (e3) {
      char* l = "string";
      break (intLastExec);
    }

    if (e4) {
      intLastExec = 10;
      float m = 3.0;
      continue (intLastExec);
    }
    int n = 2;
    intLastExec = n;

  } while (e1);
\end{lstlisting}
This implies having a default return type of the \texttt{break} or \texttt{continue} statements. When a \texttt{break} statement is reached we just return the variable intLastExec, which is the return value that is modifiable in every execution path. We give \texttt{continue} the same option to pass this argument, because when \texttt{continue} becomes the very last statement to be executed it must then return the same type. Still we must make sure that the very last statement is of type int. With these modifications, we would not need a defualt return value for \texttt{do} $s$ \texttt{while} (\textit{e}). This method allows for greater flexibility, but still involves siginificant overhead to take care of.\\


\textbf{d)}\\
\texttt{while} (\textit{e}) $s$\\
For the case of \texttt{break} or \texttt{continue} the approaches in c) still holds.\\
Similarly for \texttt{if} (\textit{e}) $s$, we would need to consider the case where $e$ in \texttt{while} evaluates to False immediately. In the same way, a default value before execution of the \texttt{while} (\textit{e}) $s$ must be introduced to resolve this.\\


\textbf{e)}\\
\textcolor{red}{\textbf{Modified:}}\\
\texttt{switch} (\textit{e}) \{\textit{\texttt{case statements}}\}\\
The exercise specifically asks for potential modifications for break statements. But it is worth mentioning that in the case where there are no breaks in the case statements, we just return the type of the last statement upon entering one of the case statements. \\
It should be emphasized that when mentioning \texttt{case statements} below, the default clause is included herein.\\

Now that break accepts an argument as described in c), we would not need to do any modifications. That is, when reaching  \texttt{break(val)} we just need to return val. Enforcing the fact that the very last statement in the switch statement and all break arguments are of the same type. This holds when the break(s) is/are contained within the case statements\\

Finally, we do run into a problem with the optional default clause. Consider the case where none of the cases \texttt{c} match and no default clause is included, then no statement would be executed. This would necessitate using a default value for the \texttt{switch} (\textit{e}) \{\textit{\texttt{case statements}}\}. Again, this value can be predefined by the programmer before execution of the switch statement similar to d) and b). 

